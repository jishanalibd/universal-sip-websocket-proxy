#!KAMAILIO
#
# Universal SIP WebSocket Proxy Configuration
# Handles SIP-over-WebSocket (WSS) and forwards to any backend SIP server
#

####### Global Parameters #########

#!ifdef WITH_DEBUG
debug=4
log_stderror=yes
#!else
debug=2
log_stderror=no
#!endif

memdbg=5
memlog=5

log_facility=LOG_LOCAL0
log_prefix="{$mt $hdr(CSeq) $ci} "

/* uncomment and configure the following line if you want Kamailio to 
   bind on a specific interface/port/proto (default bind on all available) */
# listen=udp:10.0.0.10:5060

# Listen on standard SIP ports
listen=udp:IPADDR:PORT
listen=tcp:IPADDR:PORT

# Listen on TLS port for SIP over TLS
#!ifdef WITH_TLS
listen=tls:IPADDR:TLSPORT
#!endif

# Listen on WebSocket ports
#!ifdef WITH_WEBSOCKETS
listen=tcp:IPADDR:WSPORT
listen=tls:IPADDR:WSSPORT
#!endif

####### Defined Values #########

# Enable TLS support
#!define WITH_TLS

# Enable WebSocket support
#!define WITH_WEBSOCKETS

# Domain for this proxy - CHANGE THIS
#!define DOMAIN "sipproxy.yourdomain.com"

# IP address for this proxy
#!ifndef IPADDR
#!define IPADDR "0.0.0.0"
#!endif

# Ports
#!define PORT 5060
#!define TLSPORT 5061
#!define WSPORT 8080
#!define WSSPORT 443

# Database (if needed)
#!define DBURL "text:///etc/kamailio/dbtext"

####### Modules Section ########

# set paths to location of modules
mpath="/usr/lib/x86_64-linux-gnu/kamailio/modules/"

loadmodule "jsonrpcs.so"
loadmodule "kex.so"
loadmodule "corex.so"
loadmodule "tm.so"
loadmodule "tmx.so"
loadmodule "sl.so"
loadmodule "rr.so"
loadmodule "pv.so"
loadmodule "maxfwd.so"
loadmodule "usrloc.so"
loadmodule "registrar.so"
loadmodule "textops.so"
loadmodule "siputils.so"
loadmodule "xlog.so"
loadmodule "sanity.so"
loadmodule "ctl.so"
loadmodule "cfg_rpc.so"
loadmodule "acc.so"
loadmodule "nathelper.so"
loadmodule "rtpengine.so"

#!ifdef WITH_TLS
loadmodule "tls.so"
#!endif

#!ifdef WITH_WEBSOCKETS
loadmodule "websocket.so"
loadmodule "xhttp.so"
#!endif

#!ifdef WITH_AUTH
loadmodule "auth.so"
loadmodule "auth_db.so"
#!endif

#!ifdef WITH_PRESENCE
loadmodule "presence.so"
loadmodule "presence_xml.so"
#!endif

# ----------------- setting module-specific parameters ---------------

# ----- jsonrpcs params -----
modparam("jsonrpcs", "pretty_format", 1)

# ----- rr params -----
modparam("rr", "enable_full_lr", 1)
modparam("rr", "append_fromtag", 0)

# ----- registrar params -----
modparam("registrar", "method_filtering", 1)
modparam("registrar", "max_expires", 3600)
modparam("registrar", "gruu_enabled", 0)

# ----- usrloc params -----
modparam("usrloc", "db_mode", 0)
modparam("usrloc", "db_url", DBURL)

# ----- acc params -----
modparam("acc", "early_media", 0)
modparam("acc", "report_ack", 0)
modparam("acc", "report_cancels", 0)
modparam("acc", "detect_direction", 0)
modparam("acc", "log_flag", 1)
modparam("acc", "log_missed_flag", 2)
modparam("acc", "failed_transaction_flag", 3)

#!ifdef WITH_TLS
# ----- tls params -----
modparam("tls", "config", "/etc/kamailio/tls.cfg")
modparam("tls", "tls_method", "TLSv1.2+")
#!endif

#!ifdef WITH_WEBSOCKETS
# ----- websocket params -----
modparam("websocket", "keepalive_mechanism", 1)
modparam("websocket", "keepalive_timeout", 30)
modparam("websocket", "keepalive_processes", 1)
modparam("websocket", "keepalive_interval", 10)
modparam("websocket", "ping_interval", 30)
#!endif

# ----- nathelper params -----
modparam("nathelper", "natping_interval", 30)
modparam("nathelper", "ping_nated_only", 1)
modparam("nathelper", "sipping_bflag", 7)
modparam("nathelper", "sipping_from", "sip:pinger@DOMAIN")
modparam("nathelper", "received_avp", "$avp(RECEIVED)")

# ----- rtpengine params -----
modparam("rtpengine", "rtpengine_sock", "udp:127.0.0.1:2223")

# ----- tm params -----
modparam("tm", "failure_reply_mode", 3)
modparam("tm", "fr_timer", 30000)
modparam("tm", "fr_inv_timer", 120000)

####### Routing Logic ########

/* Main SIP request routing logic */
request_route {
    # per request initial checks
    route(REQINIT);

    # Handle requests within SIP dialogs
    route(WITHINDLG);

    ### only initial requests (no To tag)

    # Handle retransmissions
    if(t_precheck_trans()) {
        t_check_trans();
        exit;
    }
    t_check_trans();

    # record routing for dialog forming requests (in case they are routed)
    if (is_method("INVITE|SUBSCRIBE")) {
        record_route();
    }

    # account only INVITEs
    if (is_method("INVITE")) {
        setflag(1); # do accounting
    }

    # handle presence related requests
    route(PRESENCE);

    # handle registrations
    route(REGISTRAR);

    if ($rU==$null) {
        # request with no Username in RURI
        sl_send_reply("484","Address Incomplete");
        exit;
    }

    # dispatch requests to foreign domains
    route(RELAY);
}

# Wrapper for relaying requests
route[RELAY] {
    # enable additional event routes for forwarded requests
    # - serial forking, RTP relaying handling, a.s.o.
    if (is_method("INVITE|BYE|SUBSCRIBE|UPDATE")) {
        if(!t_is_set("branch_route")) t_on_branch("MANAGE_BRANCH");
    }
    if (is_method("INVITE|SUBSCRIBE|UPDATE")) {
        if(!t_is_set("onreply_route")) t_on_reply("MANAGE_REPLY");
    }
    if (is_method("INVITE")) {
        if(!t_is_set("failure_route")) t_on_failure("MANAGE_FAILURE");
    }

    # Handle NAT and WebRTC
    route(NATMANAGE);

    if (!t_relay()) {
        sl_reply_error();
    }
    exit;
}

# Per SIP request initial checks
route[REQINIT] {
#!ifdef WITH_WEBSOCKETS
    if (nat_uac_test(64)) {
        # Do NAT traversal stuff for requests from a WebSocket
        # connection - even if it is not behind a NAT!
        # This won't be needed in the future if Kamailio and the
        # WebSocket client support Outbound and Path.
        force_rport();
        if (is_method("REGISTER")) {
            fix_nated_register();
        } else {
            if (!add_contact_alias()) {
                xlog("L_ERR", "Error aliasing contact <$ct>\n");
                sl_send_reply("400", "Bad Request");
                exit;
            }
        }
    }
#!endif

    if (!mf_process_maxfwd_header("10")) {
        sl_send_reply("483","Too Many Hops");
        exit;
    }

    if(is_method("OPTIONS") && uri==myself && $rU==$null) {
        sl_send_reply("200","Keepalive");
        exit;
    }

    if(!sanity_check("1511", "7")) {
        xlog("Malformed SIP message from $si:$sp\n");
        exit;
    }
}

# Handle requests within SIP dialogs
route[WITHINDLG] {
    if (!has_totag()) return;

    # sequential request withing a dialog should
    # take the path determined by record-routing
    if (loose_route()) {
#!ifdef WITH_WEBSOCKETS
        if ($du == "") {
            if (!handle_ruri_alias()) {
                xlog("L_ERR", "Bad alias <$ru>\n");
                sl_send_reply("400", "Bad Request");
                exit;
            }
        }
#!endif
        route(RELAY);
        exit;
    }

    if (is_method("ACK")) {
        if ( t_check_trans() ) {
            # no loose-route, but stateful ACK;
            # must be an ACK after a 487
            # or e.g. 404 from upstream server
            route(RELAY);
            exit;
        } else {
            # ACK without matching transaction ... ignore and discard
            exit;
        }
    }
    sl_send_reply("404","Not here");
    exit;
}

# Handle SIP registrations
route[REGISTRAR] {
    if (!is_method("REGISTER")) return;

    if (!save("location")) {
        sl_reply_error();
    }
    exit;
}

# Presence server processing
route[PRESENCE] {
    if(!is_method("PUBLISH|SUBSCRIBE")) return;

    # if presence enabled, this part will not be executed
    sl_send_reply("404", "Not here");
    exit;
}

# Caller NAT detection and handling
route[NATDETECT] {
    force_rport();
    if (nat_uac_test("19")) {
        if (is_method("REGISTER")) {
            fix_nated_register();
        } else {
            if(is_first_hop()) {
                set_contact_alias();
            }
        }
        setflag(5);
    }
    return;
}

# RTPProxy control and signaling updates for NAT traversal
route[NATMANAGE] {
#!ifdef WITH_WEBSOCKETS
    if ($(ru{uri.transport}) == "ws" || $(ru{uri.transport}) == "wss") {
        xlog("L_INFO", "Request going to WS/WSS\n");
    }
    if ($(du{uri.transport}) == "ws" || $(du{uri.transport}) == "wss") {
        xlog("L_INFO", "Request going to WS/WSS via outbound proxy\n");
    }
#!endif

    if (is_request()) {
        if(has_totag()) {
            if(check_route_param("nat=yes")) {
                setbflag(6);
            }
        }
    }
    if (!(isflagset(5) || isbflagset(6)))
        return;

    if (is_request()) {
        if (!has_totag()) {
            if(t_is_branch_route()) {
                add_rr_param(";nat=yes");
            }
        }
    }
    if (is_reply()) {
        if(isbflagset(6)) {
            set_contact_alias();
        }
    }

    # Use rtpengine for media relay
    if (is_method("INVITE|UPDATE")) {
        if (has_body("application/sdp")) {
            if (nat_uac_test("8")) {
                rtpengine_manage("replace-origin replace-session-connection ICE=remove");
            } else {
                rtpengine_manage("replace-origin replace-session-connection");
            }
        }
    }
    if (is_method("ACK") && has_body("application/sdp")) {
        rtpengine_manage("replace-origin replace-session-connection");
    }
    if (is_method("BYE|CANCEL")) {
        rtpengine_delete();
    }

    return;
}

# Manage outgoing branches
branch_route[MANAGE_BRANCH] {
    xdbg("new branch [$T_branch_idx] to $ru\n");
    route(NATMANAGE);
    return;
}

# Manage incoming replies
onreply_route[MANAGE_REPLY] {
    xdbg("incoming reply\n");
    if(status=~"[12][0-9][0-9]") {
        route(NATMANAGE);
    }

#!ifdef WITH_WEBSOCKETS
    if (nat_uac_test(64)) {
        # Do NAT traversal stuff for replies to a WebSocket connection
        add_contact_alias();
    }
#!endif
}

# Manage failure routing cases
failure_route[MANAGE_FAILURE] {
    route(NATMANAGE);

    if (t_is_canceled()) exit;

    # Handle redirect responses
    if (t_check_status("301|302")) {
        xlog("L_INFO", "Redirect received\n");
    }
}

#!ifdef WITH_WEBSOCKETS
event_route[xhttp:request] {
    set_reply_close();
    set_reply_no_connect();
    
    if ($Rp != WSPORT && $Rp != WSSPORT) {
        xlog("L_WARN", "HTTP request received on $Rp\n");
        xhttp_reply("403", "Forbidden", "", "");
        exit;
    }

    xlog("L_DBG", "HTTP Request Received\n");

    if ($hdr(Upgrade)=~"websocket"
            && $hdr(Connection)=~"Upgrade"
            && $rm=~"GET") {

        # Validate Origin - optional but recommended
        # if ($hdr(Origin) != "https://phone.yourdomain.com") {
        #     xlog("L_WARN", "Origin check failed\n");
        #     xhttp_reply("403", "Forbidden", "", "");
        #     exit;
        # }

        # ws_handle_handshake() exits (no further configuration file
        # processing of the request) when complete.
        if (ws_handle_handshake())
        {
            # Optional... cache some information about the
            # successful connection
            exit;
        }
    }

    xhttp_reply("404", "Not Found", "", "");
}

event_route[websocket:closed] {
    xlog("L_INFO", "WebSocket connection from $si:$sp has closed\n");
}
#!endif
